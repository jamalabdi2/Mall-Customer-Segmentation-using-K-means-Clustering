# -*- coding: utf-8 -*-
"""Customer Clustering using K-means.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yEYCbaRdGibsTaqkuLHOpClS14529-Kc

# **MALL CUSTOMER SEGMENTATION**

**1. Dataset Description and Problem statement**

Aim ---> To cluster Mall Customer based on numerical and categorical features.
It is an Unsupervised Learning problem statement.

**Dataset Attributes**

1. CustomerID: it is a unique ID assigned to each customer
2. Gender: Gender of the customer either Male or Female.
3. Age: Age of the customer, from 18
4. Annual Income (k$): Annual income of the customer.
5. Spending Score(1-1000): Score assigned by the mall based on customer behavior and spending nature.

# **1. Dataset Gathering and Loading**
"""

# Commented out IPython magic to ensure Python compatibility.
# import the necessary libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.cluster import KMeans
from sklearn.preprocessing import StandardScaler
# %matplotlib inline
sns.set()
import warnings
warnings.filterwarnings('ignore')

#!pip install opendatasets
import opendatasets
dataset_url = 'https://www.kaggle.com/datasets/vjchoudhary7/customer-segmentation-tutorial-in-python'
opendatasets.download(dataset_url)

# load dataset to pandas dataframe
data_path = '/content/customer-segmentation-tutorial-in-python/Mall_Customers.csv'
customer_data = pd.read_csv(data_path)
customer_data.head()

# shape of the dataset
customer_data.shape

# information about the dataset
customer_data.info()

# statistical information about numerical columns
customer_data.describe()

# columns of the datasets
customer_data.columns

# looking for null values
customer_data.isnull().sum()

"""#**2. Data Analysis**"""

numerical_columns = customer_data.select_dtypes(['int64']).columns.to_list()
categorical_columns = customer_data.select_dtypes(['object']).columns.to_list()
print('Numerical columns: ',numerical_columns)
print('Categorical columns: ',categorical_columns)
numerical_columns.pop(0)
numerical_columns

"""**2.1 Distribution of numerical columns using violinplot,boxplot, and distplot**"""

def make_plot(df,plot_kind,columns):
  plot_kind = plot_kind.lower()
  
  plot_func = {
      'violin':sns.violinplot,
      'boxplot':sns.boxplot,
      'distplot':sns.distplot
  }
  
  fig = plt.figure(figsize=(10,3))
  for index,column in enumerate(columns):
    axis = fig.add_subplot(1,3,index+1)
    if plot_kind in ['violin','boxplot']:
      plot_func[plot_kind](y=df[column],ax=axis)
      plt.title(f'{plot_kind} plot for: {column}')
    else:
      plot_func[plot_kind](df[column],ax=axis)
      plt.title(f'{plot_kind} plot for: {column}')

  plt.tight_layout()
  plt.show()

plot_kinds = ['violin','boxplot','distplot']

for item in plot_kinds:
  make_plot(customer_data,item,numerical_columns)

# countplot for gender
customer_data['Gender'].value_counts()

sns.countplot(customer_data['Gender'].value_counts())
plt.title('Distribution of Gender')
plt.show()

"""**2.2 Relationships between each columns**"""

customer_data.columns

relationship = {
    'Age Vs Income':['Age','Annual Income (k$)'],
    'Age Vs Spending Score':['Age','Spending Score (1-100)'],
    'Gender Vs Annual Income':['Gender','Annual Income (k$)'],
    'Annual Income vs Spending Score':['Annual Income (k$)','Spending Score (1-100)'],
    'Gender Vs Spending Score':['Gender','Spending Score (1-100)']
    }

titles = list(relationship.keys())
#plot_columns

columns_plot= list(relationship.values())
#def relationship_plot(df,titles,columns_plot):

from pandas.core.window.rolling import Axis


def relationship_plot(df,titles,columns_plot):
  fig = plt.figure(figsize=(10,8))
  for index,column_name in enumerate(columns_plot):
    axis = fig.add_subplot(2,3,index+1)
    sns.scatterplot(x=df[column_name[0]],y=df[column_name[1]],ax=axis)
    plt.title(f'{titles[index]}')
  plt.tight_layout()
  plt.show()



relationship_plot(customer_data,titles,columns_plot)

"""# **3.Preprocessing**

**3.1 Standard Scalling**
"""

# select only two columns: Annual Income (k$) and Spending Score (1-100)
features = customer_data.iloc[:,[3,4]]
scaler = StandardScaler()
scaled_values = scaler.fit_transform(features)
scaled_values

"""**Finding optimal number of clusters using Elbow method**"""

cluster_error = []
cluster_range = range(1,11)

for cluster in cluster_range:
  kmeans = KMeans(n_clusters=cluster,init='k-means++')
  kmeans.fit(scaled_values)
  cluster_error.append(kmeans.inertia_)
plt.figure(figsize=(8,4))
plt.plot(cluster_range,cluster_error,marker = '.',color='r')
plt.xlabel('Number of clusters')
plt.ylabel('Error rate')
plt.title('Elbow Method for choosing optimum number of clusters to use')
plt.show()

"""**Elbow points 4,3,5**

# **4. Modeling**
"""

def train(n_cluster,train_data,df):
  kmeans = KMeans(n_clusters = n_cluster,init='k-means++',random_state=4)
  kmeans.fit(train_data)
  labels = kmeans.labels_
  return labels

# kmeans with 3 clusters
labels3 = train(3,scaled_values,customer_data)
customer_data['Label3'] = labels3
# kmeans with 4 clusters
labels4 = train(4,scaled_values,customer_data)
customer_data['Label4'] = labels4
# kmeans with 5 clusters
labels5 = train(5,scaled_values,customer_data)
customer_data['Label5'] = labels5

customer_data = customer_data.drop('Cluster_ID',axis=1)

clusters = ['Label3','Label4','Label5']
titles = ['Kmeans with 3 Clusters','Kmeans with 4 Clusters','Kmeans with 5 Clusters']

def cluster_plot(clusters,data,titles):
  fig = plt.figure(figsize=(14,4))
  x=data['Annual Income (k$)']
  y=data['Spending Score (1-100)']

  for index,cluster in enumerate(clusters):
    axis = fig.add_subplot(1,3,index+1)
    sns.scatterplot(x=x,y=y,hue = data[cluster], style =data[cluster],ax=axis)
    plt.title(titles[index])
  plt.tight_layout()
  plt.show()

cluster_plot(clusters,customer_data,titles)